<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>The Floor – Operator</title>
  <style>
    :root{
      --bg:#0b1b2b;
      --text:#fff;
      --muted:#b7c7d8;
    }
    *{ box-sizing:border-box; font-family:system-ui, Arial; }
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 50% 0%, #1a4fa340, transparent), var(--bg);
      color:var(--text);
      min-height:100vh;
    }
    .screen{ display:none; min-height:100vh; padding:24px; }
    .screen.active{ display:flex; align-items:center; justify-content:center; }

    /* MENU */
    .card{
      width:min(1100px, 100%);
      background: linear-gradient(180deg, #ffffff10, #ffffff08);
      border:1px solid #ffffff18;
      border-radius:24px;
      padding:24px;
      box-shadow:0 12px 40px #00000055;
    }
    h1{ margin:0 0 12px; font-size:28px; }
    .hint{ color:var(--muted); font-size:14px; margin-bottom:18px; }
    .grid{ display:grid; grid-template-columns: repeat(3, 1fr); gap:14px; }
    .tile{
      padding:18px; border-radius:18px; cursor:pointer; user-select:none;
      background: linear-gradient(180deg, #ffffff12, #ffffff08);
      border:1px solid #ffffff1a;
      transition: transform .08s ease, border-color .08s ease, background .08s ease;
    }
    .tile:hover{ transform: translateY(-2px); border-color:#ffffff30; background: linear-gradient(180deg, #ffffff18, #ffffff0c); }
    .tile .name{ font-size:20px; font-weight:900; }
    .tile .sub{ margin-top:6px; color:var(--muted); font-size:13px; }
    .num{ float:right; opacity:.7; font-weight:800; }

    /* READY (nazwa kategorii full screen) */
    .bigTitle{
      font-size:min(96px, 9vw);
      font-weight:1000;
      letter-spacing:1px;
      text-align:center;
      text-shadow:0 0 28px #00000080;
      padding:24px;
    }
    .readyHint{
      margin-top:18px;
      text-align:center;
      color:var(--muted);
      font-size:16px;
      opacity:.85;
    }
    kbd{
      padding:4px 10px;
      border-radius:12px;
      border:1px solid #ffffff25;
      background:#00000035;
      color:#fff;
      font-size:14px;
      font-weight:800;
    }

    /* COUNTDOWN */
    .countWrap{ text-align:center; }
    .count{
      font-size:min(140px, 14vw);
      font-weight:1000;
      letter-spacing:2px;
      text-shadow:0 0 28px #00000080;
    }
    .go{ animation: pop .35s ease-out; }
    @keyframes pop{ from{ transform:scale(.92); opacity:.6 } to{ transform:scale(1); opacity:1 } }

    /* ROUND (tylko zdjęcie + czasy) */
    .stage{
      width:min(1100px, 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:18px;
    }
    .photoWrap{
      width:100%;
      aspect-ratio: 16/9;
      border-radius:24px;
      overflow:hidden;
      border:1px solid #ffffff22;
      background:#00000035;
      box-shadow:0 12px 40px #00000055;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    img{ width:100%; height:100%; object-fit:cover; display:block; }

    .times{
      width:100%;
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:0 8px;
      margin-top:-6px;
    }
    .time{
      font-size:84px;
      font-weight:900;
      letter-spacing:1px;
      text-shadow:0 0 28px #00000080;
      min-width: 280px;
    }
    .time.right{ text-align:right; }
    .active{
      filter: brightness(1.25);
      animation: pulse 1.1s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{ transform: translateY(0); }
      50%{ transform: translateY(-2px); }
    }
  </style>
</head>
<body>

  <!-- MENU -->
  <div id="menu" class="screen active">
    <div class="card">
      <h1>Wybierz kategorię</h1>
      <div class="hint">Kliknij kafelek lub naciśnij klawisz 1–9.</div>
      <div id="grid" class="grid"></div>
    </div>
  </div>

  <!-- READY -->
  <div id="ready" class="screen">
    <div>
      <div id="readyTitle" class="bigTitle">Kategoria</div>
      <div class="readyHint">Gdy gracz powie „gotowy” → Operator naciska <kbd>Enter</kbd></div>
    </div>
  </div>

  <!-- COUNTDOWN -->
  <div id="countdown" class="screen">
    <div class="countWrap">
      <div id="countNum" class="count">3</div>
    </div>
  </div>

  <!-- ROUND -->
  <div id="round" class="screen">
    <div class="stage">
      <div class="photoWrap">
        <img id="photo" alt="zdjęcie" />
      </div>
      <div class="times">
        <div id="timeA" class="time active">01:00</div>
        <div id="timeB" class="time right">01:00</div>
      </div>
    </div>
  </div>

<script>
  // ====== SCREENS ======
  const $menu = document.getElementById("menu");
  const $ready = document.getElementById("ready");
  const $countdown = document.getElementById("countdown");
  const $round = document.getElementById("round");

  function show(el){
    [$menu, $ready, $countdown, $round].forEach(x => x.classList.remove("active"));
    el.classList.add("active");
  }

  // ====== UI refs ======
  const photo = document.getElementById("photo");
  const elA = document.getElementById("timeA");
  const elB = document.getElementById("timeB");
  const grid = document.getElementById("grid");
  const countNum = document.getElementById("countNum");
  const readyTitle = document.getElementById("readyTitle");

  // ====== CONFIG ======
  const ROUND_SECONDS = 60;
  const STEP_MS = 2000; // 2 sekundy na: 3,2,1,START

  // ====== STATE: TIMERY ======
  let timeA = ROUND_SECONDS;
  let timeB = ROUND_SECONDS;
  let active = "A";
  let running = false;
  let tick = null;

  // ====== STATE: KATEGORIE/ZDJĘCIA ======
  let categories = null;
  let categoryNames = [];
  let currentCategory = null;

  // dwie talie dla A i B
  let deckA = [], deckB = [];
  let idxA = 0, idxB = 0;

  // żeby operator nie odpalił startu 10 razy
  let startArmed = false;

  function fmt(s){
    s = Math.max(0, s);
    const mm = String(Math.floor(s/60)).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    return `${mm}:${ss}`;
  }

  function render(){
    elA.textContent = fmt(timeA);
    elB.textContent = fmt(timeB);
    elA.classList.toggle("active", active === "A");
    elB.classList.toggle("active", active === "B");
  }

  function shuffle(arr){
    for (let i = arr.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function nextImageFor(player){
    if (player === "A") {
      if (!deckA.length) return;
      if (idxA >= deckA.length) { shuffle(deckA); idxA = 0; }
      photo.src = deckA[idxA++];
    } else {
      if (!deckB.length) return;
      if (idxB >= deckB.length) { shuffle(deckB); idxB = 0; }
      photo.src = deckB[idxB++];
    }
  }

  function stopTick(){
    if (tick) { clearInterval(tick); tick = null; }
  }

  function startTick(){
    if (tick) return;
    tick = setInterval(() => {
      if (!running) return;

      if (active === "A") {
        timeA = Math.max(0, timeA - 1);
        if (timeA === 0) running = false;
      } else {
        timeB = Math.max(0, timeB - 1);
        if (timeB === 0) running = false;
      }

      render();
      if (!running) flash();
    }, 1000);
  }

  // W rundzie Enter/Spacja = pauza/wznów (ale pierwsze uruchomienie robi startSequence)
  function toggleRun(){
    running = !running;
    if (running) startTick();
    render();
  }

  // POPRAWNA (P) -> zamiana gracza + nowe zdjęcie dla wchodzącego
  function correct(){
    if (!$round.classList.contains("active")) return;
    active = (active === "A") ? "B" : "A";
    nextImageFor(active);
    render();
  }

  // PAS (Q) -> -3s aktywnego + nowe zdjęcie, bez zmiany gracza
  function pass(){
    if (!$round.classList.contains("active")) return;
    if (active === "A") timeA = Math.max(0, timeA - 3);
    else timeB = Math.max(0, timeB - 3);
    nextImageFor(active);
    render();
  }

  function resetRound(){
    running = false;
    stopTick();
    timeA = ROUND_SECONDS;
    timeB = ROUND_SECONDS;
    active = "A";
    render();
  }

  function flash(){
    document.body.animate(
      [{filter:'brightness(1)'},{filter:'brightness(1.6)'},{filter:'brightness(1)'}],
      {duration:350, iterations:2}
    );
  }

  // ====== MENU / KATEGORIE ======
  function renderMenu(){
    grid.innerHTML = "";
    categoryNames.forEach((name, i) => {
      const num = i + 1;
      const d = document.createElement("div");
      d.className = "tile";
      d.innerHTML = `<div class="name">${name}<span class="num">${num}</span></div>
                     <div class="sub">${categories[name].dir} • ${categories[name].count} zdjęć</div>`;
      d.onclick = () => selectCategory(num);
      grid.appendChild(d);
    });
  }

  async function buildDecksForCategory(name){
    const cat = categories[name];
    const urls = [];
    for (let i = 1; i <= cat.count; i++){
      const n = String(i).padStart(2, "0");
      urls.push(`${cat.dir}/${n}.${cat.ext}`);
    }

    // preload (ignorujemy brakujące)
    await Promise.all(urls.map(url => new Promise(resolve => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = url;
    })));

    deckA = shuffle([...urls]);
    deckB = shuffle([...urls]);
    idxA = 0; idxB = 0;
  }

  // Po wyborze kategorii: kafelki znikają, pokazuje się nazwa na full ekranie.
  async function selectCategory(n){
    const name = categoryNames[n - 1];
    if (!name) return;

    currentCategory = name;
    await buildDecksForCategory(currentCategory);

    // przygotuj rundę, ale NIC nie startuj
    resetRound();
    startArmed = true;

    // pokaż ekran nazwy kategorii
    readyTitle.textContent = currentCategory;
    show($ready);
  }

  function wait(ms){ return new Promise(res => setTimeout(res, ms)); }

  // Enter na ekranie READY uruchamia sekwencję: 3..2..1..START (po 2 sek) -> pokaz rundę -> pierwsze zdjęcie -> start zegara A
  async function startSequence(){
    if (!startArmed) return;
    startArmed = false;

    // odliczanie
    show($countdown);

    const steps = ["3","2","1","START"];
    for (const s of steps){
      countNum.textContent = s;
      countNum.classList.add("go");
      await wait(120);
      countNum.classList.remove("go");
      await wait(STEP_MS - 120);
    }

    // start rundy: pierwsze zdjęcie + start czasu A
    active = "A";
    nextImageFor("A");
    show($round);

    running = true;
    startTick();
    render();
  }

  // ====== KEYBOARD ======
  window.addEventListener("keydown", (e) => {
    const k = (e.key || "").toLowerCase();

    // MENU: 1..9 wybór kategorii
    if ($menu.classList.contains("active")) {
      if (k >= "1" && k <= "9") { selectCategory(parseInt(k,10)); return; }
    }

    // READY: Enter startuje sekwencję (gracz mówi "gotowy")
    if ($ready.classList.contains("active")) {
      if (k === "enter") { e.preventDefault(); startSequence(); return; }
      if (k === "m") { show($menu); return; }
    }

    // ROUND: Enter/Spacja pauza/wznów, P poprawna, Q pas
    if ($round.classList.contains("active")) {
      if (k === "enter" || k === " ") { e.preventDefault(); toggleRun(); return; }
      if (k === "p") { correct(); return; }
      if (k === "q") { pass(); return; }
      if (k === "r") { resetRound(); nextImageFor("A"); return; }
      if (k === "m") { show($menu); return; }
    }
  }, {passive:false});

  // ====== INIT ======
  async function init(){
    const res = await fetch("data/categories.json");
    categories = await res.json();
    categoryNames = Object.keys(categories).slice(0, 9); // pierwsze 9
    renderMenu();
    show($menu);
    render();
  }

  init().catch(err => console.error(err));
</script>

</body>
</html>
