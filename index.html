<!--
  ORG HUB SYSTEMS
  Licensed software ‚Äì all rights reserved
-->

<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>The Floor ‚Äì Operator</title>
  <style>
    :root{
      --bg:#0b1b2b;
      --text:#fff;
      --muted:#b7c7d8;
    }
    *{ box-sizing:border-box; font-family:system-ui, Arial; }
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 50% 0%, #1a4fa340, transparent), var(--bg);
      color:var(--text);
      min-height:100vh;
    }
    /* ====== FIXED 1920x1080 VIEWPORT ====== */
body{
  overflow: hidden;
}

#viewport{
  width: 1920px;
  height: 1080px;
  background: inherit;
  transform-origin: top left;
}

/* skalowanie do rozmiaru okna */
@media (max-width: 1920px), (max-height: 1080px){
  #viewport{
    transform: scale(
      min(
        calc(100vw / 1920),
        calc(100vh / 1080)
      )
    );
  }
}

    .screen{ display:none; min-height:100vh; padding:24px; }
    .screen.active{ display:flex; align-items:center; justify-content:center; }

    /* MENU (operator setup) */
    .card{
      width:min(1100px, 100%);
      background: linear-gradient(180deg, #ffffff10, #ffffff08);
      border:1px solid #ffffff18;
      border-radius:24px;
      padding:18px;
      box-shadow:0 12px 40px #00000055;
    }
    .topRow{ display:flex; gap:12px; flex-wrap:wrap; margin-bottom:12px; }
    .inputBox{
      flex:1 1 240px;
      background:#00000025;
      border:1px solid #ffffff18;
      border-radius:18px;
      padding:10px;
    }
    .inputBox input{
      width:100%;
      padding:12px 14px;
      border-radius:14px;
      border:1px solid #ffffff22;
      background:#00000030;
      color:#fff;
      outline:none;
      font-size:18px;
      font-weight:900;
      letter-spacing:.3px;
    }
    .grid{ display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; }
    .tile{
      padding:14px;
      border-radius:18px;
      cursor:pointer;
      user-select:none;
      background: linear-gradient(180deg, #ffffff12, #ffffff08);
      border:1px solid #ffffff1a;
      transition: transform .08s ease, border-color .08s ease, background .08s ease;
      min-height:78px;
      display:flex;
      align-items:center;
    }
    /* ====== LOADED CATEGORY TILE ====== */
/* ====== USED CATEGORY (this session) ====== */
.tile.loaded{
  border-color: rgba(220, 0, 0, 0.65) !important;
  box-shadow: 0 0 0 2px rgba(220, 0, 0, 0.25) inset, 0 0 22px rgba(220, 0, 0, 0.25);
  background: linear-gradient(180deg, rgba(220,0,0,0.18), rgba(255,255,255,0.08));
}

    .tile:hover{ transform: translateY(-2px); border-color:#ffffff30; background: linear-gradient(180deg, #ffffff18, #ffffff0c); }
    .tile input{
      width:100%;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid #ffffff22;
      background:#00000020;
      color:#fff;
      outline:none;
      font-size:18px;
      font-weight:1000;
      letter-spacing:.3px;
    }

    /* READY (full screen title only) */
    .bigTitle{
      font-size:min(96px, 9vw);
      font-weight:1000;
      letter-spacing:1px;
      text-align:center;
      text-shadow:0 0 28px #00000080;
      padding:24px;
    }

    /* COUNTDOWN */
    .countWrap{ text-align:center; }
    .count{
      font-size:min(140px, 14vw);
      font-weight:1000;
      letter-spacing:2px;
      text-shadow:0 0 28px #00000080;
    }
    .go{ animation: none; }
    @keyframes pop{ from{ opacity:.6 } to{ opacity:1 } }

    /* ROUND (only photo + times) */
    .stage{
      width:min(1100px, 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:18px;
    }
    .photoWrap{
      width:100%;
      aspect-ratio: 16/9;
      border-radius:24px;
      overflow:hidden;
      border:1px solid #ffffff22;
      background:#00000035;
      box-shadow:0 12px 40px #00000055;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    img{ width:100%; height:100%; object-fit:cover; display:block; }

    .times{
      width:100%;
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:0 8px;
      margin-top:-6px;
    }
    .time{
      font-size:84px;
      font-weight:900;
      letter-spacing:1px;
      text-shadow:0 0 28px #00000080;
      min-width: 280px;
    }
    .time.right{ text-align:right; }
    .active{
      filter: brightness(1.25);
    }
    
    @keyframes pulse{
      0%,100%{ transform: translateY(0); }
      50%{ transform: translateY(-2px); }
    }

    /* WINNER (no extra hints) */
    .winnerWrap{ text-align:center; }
    .winnerTitle{
      font-size:min(120px, 12vw);
      font-weight:1000;
      letter-spacing:2px;
      text-shadow:0 0 32px #00000090;
    }
    .winnerName{
      margin-top:10px;
      font-size:min(84px, 9vw);
      font-weight:1000;
      text-shadow:0 0 28px #00000080;
    }
    /* ====== BRANDING ====== */
#branding{
  position: absolute;
  top: 24px;
  right: 32px;
  font-size: 18px;
  font-weight: 900;
  letter-spacing: 2px;
  opacity: 0.85;
  pointer-events: none; /* ≈ºeby nigdy nie ≈Çapa≈Ç klik√≥w */
  text-transform: uppercase;
}
/* ====== FULLSCREEN BUTTON ====== */
#fsBtn{
  position:absolute;
  top:24px;
  left:32px;
  width:44px;
  height:44px;
  border-radius:14px;
  border:1px solid #ffffff25;
  background:#00000035;
  color:#fff;
  font-size:20px;
  font-weight:900;
  cursor:pointer;
  opacity:.85;
  user-select:none;
}
#fsBtn:hover{ opacity:1; }

/* ====== ANSWER BELOW PHOTO ====== */
.answer{
  width:100%;
  min-height:52px;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:10px 16px;
  border-radius:18px;
  border:1px solid #ffffff18;
  background:#00000025;
  font-size:56px;
  font-weight:1000;
  letter-spacing:.5px;
  text-align:center;
  opacity:0;               /* domy≈õlnie niewidoczny */
  transform: translateY(-4px);
  transition: opacity .12s ease, transform .12s ease;
}
.answer.show{
  opacity:1;
  transform: translateY(0);
}
.loadBtn{
  padding:12px 16px;
  border-radius:16px;
  border:1px solid #ffffff25;
  background:#00000035;
  color:#fff;
  font-size:16px;
  font-weight:900;
  letter-spacing:.5px;
  cursor:pointer;
  opacity:.9;
}
.loadBtn:hover{ opacity:1; }
    
/* ====== HIDE OPERATOR BUTTONS IN FULLSCREEN (robust) ====== */
:fullscreen #fsBtn,
:fullscreen #loadBtn,
:fullscreen #sCatBtn,
:fullscreen #sOkBtn,
:fullscreen #sPassBtn{
  display:none !important;
}

/* Safari / WebKit */
:-webkit-full-screen #fsBtn,
:-webkit-full-screen #loadBtn,
:-webkit-full-screen #sCatBtn,
:-webkit-full-screen #sOkBtn,
:-webkit-full-screen #sPassBtn{
  display:none !important;
}


    /* ====== PHOTO FEEDBACK ====== */
.photoWrap{
  position: relative;
}

.photoWrap.correct{
  box-shadow: 0 0 0 6px rgba(0, 200, 0, 0.9),
              0 0 25px rgba(0, 200, 0, 0.6);
  border-radius: 18px;
}

.photoWrap.wrong{
  box-shadow: 0 0 0 6px rgba(220, 0, 0, 0.9),
              0 0 25px rgba(220, 0, 0, 0.6);
  border-radius: 18px;
}
/* ====== TIMES: NAMES + LABELS ====== */
.times{
  width:100%;
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-top:100px;
  padding:0 40px;
}

.timeRow{
  display:flex;
  align-items:center;
  gap:14px;
  color:#fff;
  font-weight:900;
}

.timeRow.left{ justify-content:flex-start; }
.timeRow.right{ justify-content:flex-end; }

.playerLabel{
  font-size:18px;
  opacity:.7;
  letter-spacing:1px;
  white-space:nowrap;
}

.playerName{
  font-size:50px;
  text-transform:uppercase;
  white-space:nowrap;
}

.time{
  font-size:60px;
  min-width:110px;
  text-align:center;
}
/* ====== HIDE PLAYER LABELS (PLAYER A/B) ====== */
.playerLabel{
  display:none !important;
}
    /* ====== ANSWER OVERLAY (NO LAYOUT SHIFT) ====== */
.stage{
  position: relative;
}

#answer{
  position: absolute;
  left: 0;
  right: 0;
  bottom: 90px;          /* nad zegarami ‚Äî w razie czego zmienimy */
  text-align: center;
  pointer-events: none;
  margin: 0 !important;  /* ≈ºeby nie pcha≈Ço layoutu */
}

/* je≈õli masz .answer zamiast #answer, dodaj te≈º: */
.answer{
  position: absolute;
  left: 0;
  right: 0;
  bottom: 90px;
  pointer-events: none;
  margin: 0 !important;
}

  </style>
</head>
<body>
  
<div id="viewport">
<div id="branding">ORG HUB SYSTEMS COLOUR RED</div>
  <button id="fsBtn" title="Full screen">‚õ∂</button>

  <!-- MENU (operator setup) -->
  <div id="menu" class="screen active">
    <div class="card">
      <div class="topRow">
        <div class="inputBox">
          <input id="nameA" type="text" placeholder="Player A" />
        </div>
        <div class="inputBox">
          <input id="nameB" type="text" placeholder="Player B" />
        </div>

      </div>
      <div id="grid" class="grid"></div>
      <div style="display:flex; gap:12px; margin:12px 0;">
  <button id="loadBtn" class="loadBtn">üìÅ Wczytaj folder</button>
  <input id="folderInput" type="file" webkitdirectory directory multiple accept="image/*" style="display:none" />
</div>
    </div>
  </div>

  <!-- READY -->
  <div id="ready" class="screen">
    <div>
      <div id="readyTitle" class="bigTitle">Kategoria</div>
    </div>
  </div>

  <!-- COUNTDOWN -->
  <div id="countdown" class="screen">
    <div class="countWrap">
      <div id="countNum" class="count">3</div>
    </div>
  </div>

  <!-- ROUND -->
  <div id="round" class="screen">
    <div class="stage">
      <div class="photoWrap">
        <img id="photo" alt="zdjƒôcie" />
      </div>
      <div id="answer" class="answer"></div>
<div class="times">
  <!-- LEWA: Player A ‚Äì czas ‚Äì imiƒô -->
  <div class="timeRow left">
    <div class="playerLabel">PLAYER A</div>
    <div id="timeA" class="time active">01:00</div>
    <div id="nameA_live" class="playerName"></div>
  </div>

  <!-- PRAWA: imiƒô ‚Äì czas ‚Äì Player B -->
  <div class="timeRow right">
    <div id="nameB_live" class="playerName"></div>
    <div id="timeB" class="time">01:00</div>
    <div class="playerLabel">PLAYER B</div>
  </div>
</div>

    </div>
  </div>

  <!-- WINNER -->
  <div id="winner" class="screen">
    <div class="winnerWrap">
      <div class="winnerTitle">ZWYCIƒòZCA!!!</div>
      <div id="winnerName" class="winnerName">‚Äî</div>
    </div>
  </div>

<script>
  // ====== SCREENS ======
  const $menu = document.getElementById("menu");
  const $ready = document.getElementById("ready");
  const $countdown = document.getElementById("countdown");
  const $round = document.getElementById("round");
  const $winner = document.getElementById("winner");

  function show(el){
    [$menu, $ready, $countdown, $round, $winner].forEach(x => x.classList.remove("active"));
    el.classList.add("active");
  }

  // ====== UI refs ======
  const photo = document.getElementById("photo");
  const photoWrap = document.querySelector(".photoWrap");
  const answerEl = document.getElementById("answer");
  const fsBtn = document.getElementById("fsBtn");
  const elA = document.getElementById("timeA");
  const elB = document.getElementById("timeB");
  const grid = document.getElementById("grid");
  const countNum = document.getElementById("countNum");
  const readyTitle = document.getElementById("readyTitle");
  const winnerNameEl = document.getElementById("winnerName");

  const nameAInput = document.getElementById("nameA");
  const nameBInput = document.getElementById("nameB");
  const loadBtn = document.getElementById("loadBtn");
  const folderInput = document.getElementById("folderInput");
  const nameA_live = document.getElementById("nameA_live");
  const nameB_live = document.getElementById("nameB_live");

  // ====== CONFIG ======
  const ROUND_SECONDS = 60;
  const STEP_MS = 1000;
  const ANSWER_MS = 1400; // ile ms pokazujemy odpowied≈∫ po P/Q
  const WRONG_HOLD_MS = 3000; // ile ms trzymamy z≈Çe zdjƒôcie po Q
  let actionLock = false; // blokuje spam P/Q podczas pokazywania odpowiedzi

  // ====== STORAGE KEYS ======
  const LS_A = "floor_name_a";
  const LS_B = "floor_name_b";
  const LS_CAT = "floor_cat_labels"; // JSON array 9 element√≥w
  const LS_LOADED = "floor_loaded_slots"; // JSON array 9 boolean

  // ====== STATE: TIMERS ======
  let timeA = ROUND_SECONDS;
  let timeB = ROUND_SECONDS;
  let active = "A";
  let running = false;
  let tick = null;
  let paused = false;


  // ====== STATE: categories/images ======
  let categories = null;        // JSON z data/categories.json (≈∫r√≥d≈Ço plik√≥w)
  let categoryKeys = [];        // klucze z categories.json (pierwsze 9)
  let catLabels = [];           // etykiety wy≈õwietlane (edytowane przez operatora)
  let usedSlots = Array(9).fill(false);
  let currentCatIndex = null;   // 0..8
  let pendingCatIndex = null;
  let startArmed = false;

  // decks
  let deckA = [], deckB = [];
  let idxA = 0, idxB = 0;
  let deck = [];
  let idx = 0;

  let currentAnswer = "";

  let audioCtx = null;
  
  // ====== SFX from repo (GitHub Pages) ======
const SFX = {
  category: new Audio("assets/sfx/category.mp3"),
  correct:  new Audio("assets/sfx/correct.mp3"),
  pass:     new Audio("assets/sfx/pass.mp3"),
};

// preload
Object.values(SFX).forEach(a => {
  a.preload = "auto";
  a.volume = 1.0;
});

function playSfx(name){
  const base = SFX[name];
  if (!base) return;
  try{
    const a = base.cloneNode(true); // pozwala nak≈Çadaƒá d≈∫wiƒôki
    a.currentTime = 0;
    a.play();
  }catch(e){}
}

function beep(freq = 800, duration = 120){
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = "sine";
  osc.frequency.value = freq;

  gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration / 1000);

  osc.connect(gain);
  gain.connect(audioCtx.destination);

  osc.start();
  osc.stop(audioCtx.currentTime + duration / 1000);
}

function playDink(){
  // DZWONECZEK: ni≈ºszy i d≈Çu≈ºszy
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  const now = audioCtx.currentTime;

  const osc1 = audioCtx.createOscillator();
  const osc2 = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc1.type = "sine";
  osc2.type = "sine";

  // ni≈ºsze czƒôstotliwo≈õci + interwa≈Ç "dzwonka"
  osc1.frequency.setValueAtTime(1100, now);
  osc2.frequency.setValueAtTime(1650, now);

  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.exponentialRampToValueAtTime(0.28, now + 0.01);
  // d≈Çu≈ºszy ogon (bell)
  gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.95);

  osc1.connect(gain);
  osc2.connect(gain);
  gain.connect(audioCtx.destination);

  osc1.start(now);
  osc2.start(now);
  osc1.stop(now + 1.0);
  osc2.stop(now + 1.0);
}
  
function playBuzzer(){
  // Elektromechaniczny brzƒôczyk (BZZZT), 1s, bez pulsacji i bez opadania
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  const now = audioCtx.currentTime;

  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const shaper = audioCtx.createWaveShaper();

  // overdrive curve (chropowato≈õƒá)
  const n = 44100;
  const curve = new Float32Array(n);
  const k = 35; // agresywno≈õƒá (wiƒôksze = bardziej brudno)
  for (let i = 0; i < n; i++){
    const x = (i * 2) / n - 1;
    curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
  }
  shaper.curve = curve;
  shaper.oversample = "4x";

  osc.type = "square";
  osc.frequency.setValueAtTime(190, now); // <- tu krƒôcisz "jak stary dzwonek" (np. 160‚Äì240)

  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.linearRampToValueAtTime(0.30, now + 0.015);
  gain.gain.setValueAtTime(0.30, now + 0.98);
  gain.gain.linearRampToValueAtTime(0.0001, now + 1.0);

  osc.connect(shaper);
  shaper.connect(gain);
  gain.connect(audioCtx.destination);

  osc.start(now);
  osc.stop(now + 1.0);
}

  function fmt(s){
    s = Math.max(0, s);
    const mm = String(Math.floor(s/60)).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    return `${mm}:${ss}`;
  }

  function renderTimers(){
    elA.textContent = fmt(timeA);
    elB.textContent = fmt(timeB);
    elA.classList.toggle("active", active === "A");
    elB.classList.toggle("active", active === "B");
  }

  function shuffle(arr){
    for (let i = arr.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
// ====== LOCAL FOLDER MODE (operator loads categories) ======
let localMode = false;
let localCats = []; // [{ label, images:[{url, answer}] }]
let localObjectUrls = []; // do sprzƒÖtania

function cleanupLocalUrls(){
  for (const u of localObjectUrls) {
    try { URL.revokeObjectURL(u); } catch(e){}
  }
  localObjectUrls = [];
}

// WyciƒÖga odpowied≈∫ z nazwy pliku:
// "01.≈Åy≈ºwy figurowe.jpg" -> "≈Åy≈ºwy figurowe"
// "KrƒÖ≈ºek.jpg" -> "KrƒÖ≈ºek"
function answerFromFilename(filename){
  const base = filename.replace(/\.[^.]+$/, ""); // bez .jpg
  const parts = base.split(".");
  if (parts.length >= 2) return parts.slice(1).join(".").trim();
  return base.trim();
}

// Preload obrazk√≥w, ≈ºeby nie lagowa≈Ço w trakcie gry
async function preloadImage(url){
  await new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
    img.src = url;
  });
}

// Operator wybiera folder (z podfolderami = kategorie)
loadBtn.addEventListener("click", () => folderInput.click());
  
folderInput.addEventListener("change", async () => {
  const files = Array.from(folderInput.files || [])
    .filter(f => (f.type || "").startsWith("image/"));

  if (!files.length) return;

  // Grupowanie po pierwszym segmencie ≈õcie≈ºki: "lodowisko/01.xxx.jpg"
  const incoming = new Map(); // label -> array File
  for (const f of files){
    const rel = f.webkitRelativePath || f.name;
    const seg = rel.split("/")[0] || "Kategoria";
    if (!incoming.has(seg)) incoming.set(seg, []);
    incoming.get(seg).push(f);
  }

  // usu≈Ñ tylko jednƒÖ kategoriƒô po label (i zwolnij jej URL-e)
  function removeCategoryByLabel(label){
    const idx = localCats.findIndex(c => c.label === label);
    if (idx === -1) return;

    const old = localCats[idx];
    for (const img of old.images){
      try { URL.revokeObjectURL(img.url); } catch(e){}
      const p = localObjectUrls.indexOf(img.url);
      if (p !== -1) localObjectUrls.splice(p, 1);
    }
    localCats.splice(idx, 1);
  }

  // Dodaj/podmie≈Ñ tylko kategorie, kt√≥re w≈Ça≈õnie przysz≈Çy
  for (const [label, arr] of incoming.entries()){
    // je≈õli taka kategoria ju≈º by≈Ça, podmie≈Ñ jƒÖ
    const existingIdx = localCats.findIndex(c => c.label === label);
if (existingIdx !== -1) removeCategoryByLabel(label);

    arr.sort((a, b) => {
  const na = parseInt((a.name.match(/^(\d+)/) || [0,0])[1], 10);
  const nb = parseInt((b.name.match(/^(\d+)/) || [0,0])[1], 10);
  return na - nb;
});

    const images = arr.map(f => {
      const url = URL.createObjectURL(f);
      localObjectUrls.push(url);
      return { url, answer: answerFromFilename(f.name || "") };
    });

    const newCat = { label, images };
if (existingIdx !== -1) localCats.splice(existingIdx, 0, newCat);
else localCats.push(newCat);

    // preload tylko tej jednej kategorii (≈ºeby nie robiƒá laga)
    for (const img of images){
      await preloadImage(img.url);
    }
  }

  // sort alfabetyczny kategorii
  // localCats.sort((a,b) => a.label.localeCompare(b.label, "pl"));

  localMode = true;

  // kafelki = pierwsze 9 kategorii
  catLabels = localCats.slice(0, 9).map(c => c.label);
  saveCatLabels();

  // zaznacz jako "loaded" sloty 1..9 kt√≥re majƒÖ realnie obrazy
  loadedSlots = Array.from({length:9}, (_, i) => {
  const cat = localCats[i];
  return !!(cat && cat.images && cat.images.length);
  });
  saveLoadedSlots();
  
  // pozw√≥l za≈Çadowaƒá TEN SAM folder ponownie
  folderInput.value = "";
  
  renderMenu();
});
  
function nextImageFor(){
  if (!deck.length) return;
  if (idx >= deck.length) idx = 0;

  const item = deck[idx++];

  photo.src = (typeof item === "string") ? item : item.url;
  currentAnswer = (typeof item === "string") ? "" : (item.answer || "");
}

  // ====== TIMER (ODLICZANIE) + D≈πWIƒòK "CYK" ======

let tickSoundInterval = null; // interval d≈∫wiƒôku

function playTick(){
  beep(900, 35); // kr√≥tkie "cyk"
}

function stopTick(){
  // stop odliczania
  if (tick){
    clearInterval(tick);
    tick = null;
  }
  // stop d≈∫wiƒôku
  if (tickSoundInterval){
    clearInterval(tickSoundInterval);
    tickSoundInterval = null;
  }
}

function startTick(){
  // ≈ºeby nie dublowaƒá interwa≈Ç√≥w
  stopTick();

  // start d≈∫wiƒôku "cyk" (tylko gdy gra leci)
  playTick();
  tickSoundInterval = setInterval(() => {
    if (running) playTick();
  }, 1000);

  // start odliczania czasu
  tick = setInterval(() => {
    if (!running || paused) return;

    if (active === "A") {
      timeA = Math.max(0, timeA - 1);
      if (timeA === 0) { announceWinner("B"); return; }
    } else {
      timeB = Math.max(0, timeB - 1);
      if (timeB === 0) { announceWinner("A"); return; }
    }
    renderTimers();
  }, 1000);
}

  function announceWinner(winner){
    running = false;
    paused = false;
    stopTick();
    const winnerName = (winner === "A") ? getNameA() : getNameB();
    winnerNameEl.textContent = winnerName;
    show($winner);
      setTimeout(() => {
    resetRound();
    show($menu);
    renderMenu();
  }, 5000);

    document.body.animate(
      [{filter:'brightness(1)'},{filter:'brightness(1.8)'},{filter:'brightness(1)'}],
      {duration:450, iterations:3}
    );
  }

  function correct(){ // P
    if (!$round.classList.contains("active")) return;
    if (!running) return;
    if (actionLock) return;
   console.log("P pressed, paused before:", paused);
     playSfx("correct");
    showCorrect();
    revealAnswerThen(() => {
      active = (active === "A") ? "B" : "A";
      nextImageFor();
      renderTimers();
      clearPhotoFeedback();
    });
  }

async function pass(){ // Q
  if (!$round.classList.contains("active")) return;
  if (!running) return;
  if (actionLock) return;
  playSfx("pass");

  actionLock = true;

  // czerwona ramka + poka≈º odpowied≈∫ na CA≈ÅE 3 sekundy
  showWrong();
  showAnswerForCurrentImage();

  await wait(WRONG_HOLD_MS);

  hideAnswer();
  nextImageFor();     // ten sam gracz dostaje nowe zdjƒôcie
  renderTimers();

  clearPhotoFeedback();
  actionLock = false;
}

function resetRound(){
  running = false;
  paused = false;
  stopTick();
  timeA = ROUND_SECONDS;
  timeB = ROUND_SECONDS;
  active = "A";
  renderTimers();
}

    // ====== FULLSCREEN ======
  function isFullscreen(){
    return !!document.fullscreenElement;
  }
  async function toggleFullscreen(){
    try{
      if (!isFullscreen()) {
        await document.getElementById("viewport").requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    }catch(e){
      console.error(e);
    }
  }
  fsBtn.addEventListener("click", toggleFullscreen);

  // ====== ANSWER PARSING FROM FILENAME ======
  // Obs≈Çuguje np: assets/k1/01.Nazwa_odpowiedzi.jpg
  function getAnswerFromSrc(src){
    try{
      const clean = src.split("?")[0];
      const file = clean.split("/").pop();          // 01.Nazwa.jpg
      const base = file.replace(/\.[^.]+$/, "");    // 01.Nazwa
      const parts = base.split(".");
      if (parts.length < 2) return "";              // np. 01 -> brak odpowiedzi
      const raw = parts.slice(1).join(".");         // Nazwa_odpowiedzi
      return decodeURIComponent(raw).replace(/_/g, " ").trim();
    }catch(e){
      return "";
    }
  }

function showAnswerForCurrentImage(){
  const txt = (currentAnswer || "").trim() || getAnswerFromSrc(photo.src);
  if (!txt) return false;
  answerEl.textContent = txt;
  answerEl.classList.add("show");
  return true;
}

  function hideAnswer(){
    answerEl.classList.remove("show");
    answerEl.textContent = "";
  }

  function clearPhotoFeedback(){
  if (!photoWrap) return;
  photoWrap.classList.remove("correct", "wrong");
}

function showCorrect(){
  if (!photoWrap) return;
  clearPhotoFeedback();
  photoWrap.classList.add("correct");
}

function showWrong(){
  if (!photoWrap) return;
  clearPhotoFeedback();
  photoWrap.classList.add("wrong");
}
  
async function revealAnswerThen(doAfter){
  if (actionLock) return;
  actionLock = true;

  // poka≈º odpowied≈∫ dla AKTUALNEGO zdjƒôcia
  showAnswerForCurrentImage();

  // pauza zegara na czas wy≈õwietlania odpowiedzi
  paused = true;
  console.log("paused ON");

  await wait(ANSWER_MS);
  paused = false;

  hideAnswer();
  doAfter();

  actionLock = false;
}

  // ====== NAMES ======
  function getNameA(){ return (nameAInput.value || "").trim() || "Player A"; }
  function getNameB(){ return (nameBInput.value || "").trim() || "Player B"; }
  function loadNames(){
    nameAInput.value = localStorage.getItem(LS_A) || "";
    nameBInput.value = localStorage.getItem(LS_B) || "";
  }
  function saveNames(){
    localStorage.setItem(LS_A, (nameAInput.value || "").trim());
    localStorage.setItem(LS_B, (nameBInput.value || "").trim());
  }
  nameAInput.addEventListener("input", saveNames);
  nameBInput.addEventListener("input", saveNames);

  // ====== CATEGORY LABELS (editable display only) ======
  function loadCatLabels(){
    try{
      const raw = localStorage.getItem(LS_CAT);
      const arr = raw ? JSON.parse(raw) : null;
      if (Array.isArray(arr) && arr.length === 9) return arr;
    }catch(e){}
    // default: u≈ºyj kluczy (Kategoria1..)
    return categoryKeys.map((k, i) => `Kategoria ${i+1}`);
  }

  function saveCatLabels(){
    localStorage.setItem(LS_CAT, JSON.stringify(catLabels));
  }
  function loadLoadedSlots(){
  try{
    const raw = localStorage.getItem(LS_LOADED);
    const arr = raw ? JSON.parse(raw) : null;
    if (Array.isArray(arr) && arr.length === 9) return arr.map(Boolean);
  }catch(e){}
  return Array(9).fill(false);
}

function saveLoadedSlots(){
  localStorage.setItem(LS_LOADED, JSON.stringify(loadedSlots));
}

  function renderMenu(){
    // Je≈õli operator wczyta≈Ç folder ‚Äî kafelki oparte o localCats
if (localMode) {
  // ograniczamy do 9 kategorii na ekranie
  // (kolejne mo≈ºesz dodaƒá potem jako przewijanie, ale to nastƒôpny krok)
}
    grid.innerHTML = "";
    for (let i = 0; i < 9; i++){
      const tile = document.createElement("div");
      tile.className = "tile";
      tile.classList.toggle("loaded", !!usedSlots[i]);
     tile.onclick = () => {
    if (usedSlots[i]) return;          // zablokuj u≈ºyte
    playSfx("category");
    selectCategory(i);
  };

      const inp = document.createElement("input");
      inp.value = catLabels[i] || "";
      inp.placeholder = `Kategoria ${i+1}`;
      inp.addEventListener("click", (e) => e.stopPropagation());
      inp.addEventListener("keydown", (e) => e.stopPropagation());
      inp.addEventListener("input", () => {
        catLabels[i] = inp.value;
        saveCatLabels();
      });

      tile.appendChild(inp);
      grid.appendChild(tile);
    }
  }

  async function buildDecksForIndex(i){
    const key = categoryKeys[i];
    const cat = categories[key];

    const urls = [];
    for (let n = 1; n <= cat.count; n++){
      const nn = String(n).padStart(2, "0");
      urls.push(`${cat.dir}/${nn}.${cat.ext}`);
    }

    await Promise.all(urls.map(url => new Promise(resolve => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = url;
    })));

     deck = [...urls];   // ju≈º jest w kolejno≈õci 01..N
    idx = 0;

  }

  async function selectCategory(i){
   usedSlots[i] = true;
if (localMode) {
  saveNames();
  currentCatIndex = i;
  pendingCatIndex = i;

  const cat = localCats[i];
  if (!cat) return;

  // Decki z obiekt√≥w {url, answer}
  deck = cat.images.slice(); // ju≈º posortowane po numerze
  idx = 0;

  resetRound();
  startArmed = true;

  readyTitle.textContent = (catLabels[i] || cat.label || "").trim() || `Kategoria ${i+1}`;
  usedSlots[i] = true;
  show($ready);
  return;
}

    saveNames();
    currentCatIndex = i;
    await buildDecksForIndex(i);

    resetRound();
    startArmed = true;

    readyTitle.textContent = (catLabels[i] || "").trim() || `Kategoria ${i+1}`;
    show($ready);
  }

  function wait(ms){ return new Promise(res => setTimeout(res, ms)); }

  async function startSequence(){
    nameA_live.textContent = (nameAInput.value || "").trim();
    nameB_live.textContent = (nameBInput.value || "").trim();

    if (!startArmed) return;
    startArmed = false;
    
    if (pendingCatIndex !== null) {
    usedSlots[pendingCatIndex] = true;
    pendingCatIndex = null;
  }
  
    show($countdown);
    const steps = ["3","2","1","START"];
    for (const s of steps){
      countNum.textContent = s;
            // d≈∫wiƒôk odliczania: pik...pik...pik...piiiiiik
      if (s === "START") beep(1500, 1500);
      else beep(1000, 500);
      
      countNum.classList.add("go");
      await wait(110);
      countNum.classList.remove("go");
      await wait(STEP_MS - 110);
    }

    active = "A";
    nextImageFor();
    show($round);

    running = true;
    startTick();
    renderTimers();
  }

  // ====== KEYBOARD ======
  window.addEventListener("keydown", (e) => {
    const k = (e.key || "").toLowerCase();
      if (k === "f") { toggleFullscreen(); return; }

    // MENU: 1..9 wyb√≥r
if (k >= "1" && k <= "9") {
  const idx = parseInt(k,10) - 1;
  if (usedSlots[idx]) return;        // zablokuj u≈ºyte
  playSfx("category");
  selectCategory(idx);
  return;
}

    // READY: Enter start
    if ($ready.classList.contains("active")) {
      if (k === "enter") { e.preventDefault(); startSequence(); return; }
    }

    // ROUND: Enter/Space ignoruj (brak pauzy)
    if ($round.classList.contains("active")) {
      if (k === "enter" || k === " ") { e.preventDefault(); return; }
      if (k === "p") { correct(); return; }
      if (k === "q") { pass(); return; }
    }

    // WINNER: M do menu, R restart tej samej kategorii
    if ($winner.classList.contains("active")) {
      if (k === "m") { show($menu); return; }
      if (k === "r") {
        if (currentCatIndex !== null) {
          resetRound();
          active = "A";
          nextImageFor();
          show($round);
          running = true;
          startTick();
          renderTimers();
        } else {
          show($menu);
        }
        return;
      }
    }
  }, {passive:false});

  // ====== INIT ======
  async function init(){
    loadNames();

    const res = await fetch("data/categories.json");
    categories = await res.json();
    categoryKeys = Object.keys(categories).slice(0, 9);

    catLabels = loadCatLabels();
    renderMenu();

    show($menu);
    renderTimers();
  }

  init().catch(err => console.error(err));
  
</script>
  </div>
</body>
</html>
