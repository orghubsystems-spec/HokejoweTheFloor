<!--
  ORG HUB SYSTEMS
  Licensed software ‚Äì all rights reserved
-->

<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>The Floor ‚Äì Operator</title>
  <style>
    :root{
      --bg:#0b1b2b;
      --text:#fff;
      --muted:#b7c7d8;
    }
    *{ box-sizing:border-box; font-family:system-ui, Arial; }
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 50% 0%, #1a4fa340, transparent), var(--bg);
      color:var(--text);
      min-height:100vh;
    }
    /* ====== FIXED 1920x1080 VIEWPORT ====== */
body{
  overflow: hidden;
}

#viewport{
  width: 1920px;
  height: 1080px;
  background: inherit;
  transform-origin: top left;
}

/* skalowanie do rozmiaru okna */
@media (max-width: 1920px), (max-height: 1080px){
  #viewport{
    transform: scale(
      min(
        calc(100vw / 1920),
        calc(100vh / 1080)
      )
    );
  }
}

    .screen{ display:none; min-height:100vh; padding:24px; }
    .screen.active{ display:flex; align-items:center; justify-content:center; }

    /* MENU (operator setup) */
    .card{
      width:min(1100px, 100%);
      background: linear-gradient(180deg, #ffffff10, #ffffff08);
      border:1px solid #ffffff18;
      border-radius:24px;
      padding:18px;
      box-shadow:0 12px 40px #00000055;
    }
    .topRow{ display:flex; gap:12px; flex-wrap:wrap; margin-bottom:12px; }
    .inputBox{
      flex:1 1 240px;
      background:#00000025;
      border:1px solid #ffffff18;
      border-radius:18px;
      padding:10px;
    }
    .inputBox input{
      width:100%;
      padding:12px 14px;
      border-radius:14px;
      border:1px solid #ffffff22;
      background:#00000030;
      color:#fff;
      outline:none;
      font-size:18px;
      font-weight:900;
      letter-spacing:.3px;
    }
    .grid{ display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; }
    .tile{
      padding:14px;
      border-radius:18px;
      cursor:pointer;
      user-select:none;
      background: linear-gradient(180deg, #ffffff12, #ffffff08);
      border:1px solid #ffffff1a;
      transition: transform .08s ease, border-color .08s ease, background .08s ease;
      min-height:78px;
      display:flex;
      align-items:center;
    }
    .tile:hover{ transform: translateY(-2px); border-color:#ffffff30; background: linear-gradient(180deg, #ffffff18, #ffffff0c); }
    .tile input{
      width:100%;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid #ffffff22;
      background:#00000020;
      color:#fff;
      outline:none;
      font-size:18px;
      font-weight:1000;
      letter-spacing:.3px;
    }

    /* READY (full screen title only) */
    .bigTitle{
      font-size:min(96px, 9vw);
      font-weight:1000;
      letter-spacing:1px;
      text-align:center;
      text-shadow:0 0 28px #00000080;
      padding:24px;
    }

    /* COUNTDOWN */
    .countWrap{ text-align:center; }
    .count{
      font-size:min(140px, 14vw);
      font-weight:1000;
      letter-spacing:2px;
      text-shadow:0 0 28px #00000080;
    }
    .go{ animation: pop .25s ease-out; }
    @keyframes pop{ from{ transform:scale(.92); opacity:.6 } to{ transform:scale(1); opacity:1 } }

    /* ROUND (only photo + times) */
    .stage{
      width:min(1100px, 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:18px;
    }
    .photoWrap{
      width:100%;
      aspect-ratio: 16/9;
      border-radius:24px;
      overflow:hidden;
      border:1px solid #ffffff22;
      background:#00000035;
      box-shadow:0 12px 40px #00000055;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    img{ width:100%; height:100%; object-fit:cover; display:block; }

    .times{
      width:100%;
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:0 8px;
      margin-top:-6px;
    }
    .time{
      font-size:84px;
      font-weight:900;
      letter-spacing:1px;
      text-shadow:0 0 28px #00000080;
      min-width: 280px;
    }
    .time.right{ text-align:right; }
    .active{
      filter: brightness(1.25);
      animation: pulse 1.1s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{ transform: translateY(0); }
      50%{ transform: translateY(-2px); }
    }

    /* WINNER (no extra hints) */
    .winnerWrap{ text-align:center; }
    .winnerTitle{
      font-size:min(120px, 12vw);
      font-weight:1000;
      letter-spacing:2px;
      text-shadow:0 0 32px #00000090;
    }
    .winnerName{
      margin-top:10px;
      font-size:min(84px, 9vw);
      font-weight:1000;
      text-shadow:0 0 28px #00000080;
    }
    /* ====== BRANDING ====== */
#branding{
  position: absolute;
  top: 24px;
  right: 32px;
  font-size: 18px;
  font-weight: 900;
  letter-spacing: 2px;
  opacity: 0.85;
  pointer-events: none; /* ≈ºeby nigdy nie ≈Çapa≈Ç klik√≥w */
  text-transform: uppercase;
}
/* ====== FULLSCREEN BUTTON ====== */
#fsBtn{
  position:absolute;
  top:24px;
  left:32px;
  width:44px;
  height:44px;
  border-radius:14px;
  border:1px solid #ffffff25;
  background:#00000035;
  color:#fff;
  font-size:20px;
  font-weight:900;
  cursor:pointer;
  opacity:.85;
  user-select:none;
}
#fsBtn:hover{ opacity:1; }

/* ====== ANSWER BELOW PHOTO ====== */
.answer{
  width:100%;
  min-height:52px;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:10px 16px;
  border-radius:18px;
  border:1px solid #ffffff18;
  background:#00000025;
  font-size:56px;
  font-weight:1000;
  letter-spacing:.5px;
  text-align:center;
  opacity:0;               /* domy≈õlnie niewidoczny */
  transform: translateY(-4px);
  transition: opacity .12s ease, transform .12s ease;
}
.answer.show{
  opacity:1;
  transform: translateY(0);
}
.loadBtn{
  padding:12px 16px;
  border-radius:16px;
  border:1px solid #ffffff25;
  background:#00000035;
  color:#fff;
  font-size:16px;
  font-weight:900;
  letter-spacing:.5px;
  cursor:pointer;
  opacity:.9;
}
.loadBtn:hover{ opacity:1; }
/* ====== HIDE OPERATOR BUTTONS IN FULLSCREEN ====== */
#viewport:fullscreen #fsBtn,
#viewport:fullscreen #loadBtn,
#viewport:fullscreen #clearBtn{
  display:none !important;
}

/* Safari/Starsze WebKit */
#viewport:-webkit-full-screen #fsBtn,
#viewport:-webkit-full-screen #loadBtn,
#viewport:-webkit-full-screen #clearBtn{
  display:none !important;
}

    /* ====== PHOTO FEEDBACK ====== */
.photoWrap{
  position: relative;
}

.photoWrap.correct{
  box-shadow: 0 0 0 6px rgba(0, 200, 0, 0.9),
              0 0 25px rgba(0, 200, 0, 0.6);
  border-radius: 18px;
}

.photoWrap.wrong{
  box-shadow: 0 0 0 6px rgba(220, 0, 0, 0.9),
              0 0 25px rgba(220, 0, 0, 0.6);
  border-radius: 18px;
}
  /* ====== DISABLE PHOTO FLOATING EFFECT ====== */
#photo,
.photoWrap img{
  animation: none !important;
  transform: none !important;
}
/* ====== KILL SWITCH: NO MOTION ON ROUND SCREEN ====== */
#round, 
#round *{
  animation: none !important;
  transition: none !important;
}

  </style>
</head>
<body>
  
<div id="viewport">
<div id="branding">ORG HUB SYSTEMS 17</div>
  <button id="fsBtn" title="Full screen">‚õ∂</button>

  <!-- MENU (operator setup) -->
  <div id="menu" class="screen active">
    <div class="card">
      <div class="topRow">
        <div class="inputBox">
          <input id="nameA" type="text" placeholder="Player A" />
        </div>
        <div class="inputBox">
          <input id="nameB" type="text" placeholder="Player B" />
        </div>

      </div>
      <div id="grid" class="grid"></div>
      <div style="display:flex; gap:12px; margin:12px 0;">
  <button id="loadBtn" class="loadBtn">üìÅ Wczytaj folder</button>
  <button id="clearBtn" class="loadBtn">üßπ Wyczy≈õƒá</button>
  <input id="folderInput" type="file" webkitdirectory directory multiple accept="image/*" style="display:none" />
</div>
    </div>
  </div>

  <!-- READY -->
  <div id="ready" class="screen">
    <div>
      <div id="readyTitle" class="bigTitle">Kategoria</div>
    </div>
  </div>

  <!-- COUNTDOWN -->
  <div id="countdown" class="screen">
    <div class="countWrap">
      <div id="countNum" class="count">3</div>
    </div>
  </div>

  <!-- ROUND -->
  <div id="round" class="screen">
    <div class="stage">
      <div class="photoWrap">
        <img id="photo" alt="zdjƒôcie" />
      </div>
      <div id="answer" class="answer"></div>
      <div class="times">
        <div id="timeA" class="time active">01:00</div>
        <div id="timeB" class="time right">01:00</div>
      </div>
    </div>
  </div>

  <!-- WINNER -->
  <div id="winner" class="screen">
    <div class="winnerWrap">
      <div class="winnerTitle">ZWYCIƒòZCA!!!</div>
      <div id="winnerName" class="winnerName">‚Äî</div>
    </div>
  </div>

<script>
  // ====== SCREENS ======
  const $menu = document.getElementById("menu");
  const $ready = document.getElementById("ready");
  const $countdown = document.getElementById("countdown");
  const $round = document.getElementById("round");
  const $winner = document.getElementById("winner");

  function show(el){
    [$menu, $ready, $countdown, $round, $winner].forEach(x => x.classList.remove("active"));
    el.classList.add("active");
  }

  // ====== UI refs ======
  const photo = document.getElementById("photo");
  const photoWrap = document.querySelector(".photoWrap");
  const answerEl = document.getElementById("answer");
  const fsBtn = document.getElementById("fsBtn");
  const elA = document.getElementById("timeA");
  const elB = document.getElementById("timeB");
  const grid = document.getElementById("grid");
  const countNum = document.getElementById("countNum");
  const readyTitle = document.getElementById("readyTitle");
  const winnerNameEl = document.getElementById("winnerName");

  const nameAInput = document.getElementById("nameA");
  const nameBInput = document.getElementById("nameB");
  const loadBtn = document.getElementById("loadBtn");
  const folderInput = document.getElementById("folderInput");


  // ====== CONFIG ======
  const ROUND_SECONDS = 60;
  const STEP_MS = 1000;
  const ANSWER_MS = 1400; // ile ms pokazujemy odpowied≈∫ po P/Q
  const WRONG_HOLD_MS = 3000; // ile ms trzymamy z≈Çe zdjƒôcie po Q
  let actionLock = false; // blokuje spam P/Q podczas pokazywania odpowiedzi

  // ====== STORAGE KEYS ======
  const LS_A = "floor_name_a";
  const LS_B = "floor_name_b";
  const LS_CAT = "floor_cat_labels"; // JSON array 9 element√≥w

  // ====== STATE: TIMERS ======
  let timeA = ROUND_SECONDS;
  let timeB = ROUND_SECONDS;
  let active = "A";
  let running = false;
  let tick = null;

  // ====== STATE: categories/images ======
  let categories = null;        // JSON z data/categories.json (≈∫r√≥d≈Ço plik√≥w)
  let categoryKeys = [];        // klucze z categories.json (pierwsze 9)
  let catLabels = [];           // etykiety wy≈õwietlane (edytowane przez operatora)
  let currentCatIndex = null;   // 0..8
  let startArmed = false;

  // decks
  let deckA = [], deckB = [];
  let idxA = 0, idxB = 0;
  let currentAnswer = "";

  let audioCtx = null;

function beep(freq = 800, duration = 120){
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = "sine";
  osc.frequency.value = freq;

  gain.gain.setValueAtTime(0.001, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration / 1000);

  osc.connect(gain);
  gain.connect(audioCtx.destination);

  osc.start();
  osc.stop(audioCtx.currentTime + duration / 1000);
}

  function fmt(s){
    s = Math.max(0, s);
    const mm = String(Math.floor(s/60)).padStart(2,"0");
    const ss = String(s%60).padStart(2,"0");
    return `${mm}:${ss}`;
  }

  function renderTimers(){
    elA.textContent = fmt(timeA);
    elB.textContent = fmt(timeB);
    elA.classList.toggle("active", active === "A");
    elB.classList.toggle("active", active === "B");
  }

  function shuffle(arr){
    for (let i = arr.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
// ====== LOCAL FOLDER MODE (operator loads categories) ======
let localMode = false;
let localCats = []; // [{ label, images:[{url, answer}] }]
let localObjectUrls = []; // do sprzƒÖtania

function cleanupLocalUrls(){
  for (const u of localObjectUrls) {
    try { URL.revokeObjectURL(u); } catch(e){}
  }
  localObjectUrls = [];
}

// WyciƒÖga odpowied≈∫ z nazwy pliku:
// "01.≈Åy≈ºwy figurowe.jpg" -> "≈Åy≈ºwy figurowe"
// "KrƒÖ≈ºek.jpg" -> "KrƒÖ≈ºek"
function answerFromFilename(filename){
  const base = filename.replace(/\.[^.]+$/, ""); // bez .jpg
  const parts = base.split(".");
  if (parts.length >= 2) return parts.slice(1).join(".").trim();
  return base.trim();
}

// Preload obrazk√≥w, ≈ºeby nie lagowa≈Ço w trakcie gry
async function preloadImage(url){
  await new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve(true);
    img.onerror = () => resolve(false);
    img.src = url;
  });
}

// Operator wybiera folder (z podfolderami = kategorie)
loadBtn.addEventListener("click", () => folderInput.click());
  
folderInput.addEventListener("change", async () => {
  const files = Array.from(folderInput.files || [])
    .filter(f => (f.type || "").startsWith("image/"));

  if (!files.length) return;

  // Grupowanie po pierwszym segmencie ≈õcie≈ºki: "lodowisko/01.xxx.jpg"
  const incoming = new Map(); // label -> array File
  for (const f of files){
    const rel = f.webkitRelativePath || f.name;
    const seg = rel.split("/")[0] || "Kategoria";
    if (!incoming.has(seg)) incoming.set(seg, []);
    incoming.get(seg).push(f);
  }

  // usu≈Ñ tylko jednƒÖ kategoriƒô po label (i zwolnij jej URL-e)
  function removeCategoryByLabel(label){
    const idx = localCats.findIndex(c => c.label === label);
    if (idx === -1) return;

    const old = localCats[idx];
    for (const img of old.images){
      try { URL.revokeObjectURL(img.url); } catch(e){}
      const p = localObjectUrls.indexOf(img.url);
      if (p !== -1) localObjectUrls.splice(p, 1);
    }
    localCats.splice(idx, 1);
  }

  // Dodaj/podmie≈Ñ tylko kategorie, kt√≥re w≈Ça≈õnie przysz≈Çy
  for (const [label, arr] of incoming.entries()){
    // je≈õli taka kategoria ju≈º by≈Ça, podmie≈Ñ jƒÖ
    const existingIdx = localCats.findIndex(c => c.label === label);
if (existingIdx !== -1) removeCategoryByLabel(label);

    arr.sort((a,b) => (a.name || "").localeCompare((b.name || ""), "pl", {numeric:true}));

    const images = arr.map(f => {
      const url = URL.createObjectURL(f);
      localObjectUrls.push(url);
      return { url, answer: answerFromFilename(f.name || "") };
    });

    const newCat = { label, images };
if (existingIdx !== -1) localCats.splice(existingIdx, 0, newCat);
else localCats.push(newCat);

    // preload tylko tej jednej kategorii (≈ºeby nie robiƒá laga)
    for (const img of images){
      await preloadImage(img.url);
    }
  }

  // sort alfabetyczny kategorii
  // localCats.sort((a,b) => a.label.localeCompare(b.label, "pl"));

  localMode = true;

  // kafelki = pierwsze 9 kategorii
  catLabels = localCats.slice(0, 9).map(c => c.label);
  saveCatLabels();

  // pozw√≥l za≈Çadowaƒá TEN SAM folder ponownie
  folderInput.value = "";

  renderMenu();
});


  function nextImageFor(player){
    if (player === "A") {
      if (!deckA.length) return;
      if (idxA >= deckA.length) { shuffle(deckA); idxA = 0; }
     const item = deckA[idxA++];
    photo.src = (typeof item === "string") ? item : item.url;
    currentAnswer = (typeof item === "string") ? "" : (item.answer || "");
    } else {
      if (!deckB.length) return;
      if (idxB >= deckB.length) { shuffle(deckB); idxB = 0; }
      const item = deckB[idxB++];
    photo.src = (typeof item === "string") ? item : item.url;
    currentAnswer = (typeof item === "string") ? "" : (item.answer || "");
    }
  }

  function stopTick(){
    if (tick) { clearInterval(tick); tick = null; }
  }

  function announceWinner(winner){
    running = false;
    stopTick();
    const winnerName = (winner === "A") ? getNameA() : getNameB();
    winnerNameEl.textContent = winnerName;
    show($winner);
      setTimeout(() => {
    resetRound();
    show($menu);
    renderMenu();
  }, 5000);

    document.body.animate(
      [{filter:'brightness(1)'},{filter:'brightness(1.8)'},{filter:'brightness(1)'}],
      {duration:450, iterations:3}
    );
  }

  function startTick(){
    if (tick) return;
    tick = setInterval(() => {
      if (!running) return;

      if (active === "A") {
        timeA = Math.max(0, timeA - 1);
        if (timeA === 0) { announceWinner("B"); return; }
      } else {
        timeB = Math.max(0, timeB - 1);
        if (timeB === 0) { announceWinner("A"); return; }
      }
      renderTimers();
    }, 1000);
  }
  function correct(){ // P
    if (!$round.classList.contains("active")) return;
    if (!running) return;
    if (actionLock) return;
    showCorrect();
    revealAnswerThen(() => {
      active = (active === "A") ? "B" : "A";
      nextImageFor(active);
      renderTimers();
      clearPhotoFeedback();
    });
  }

async function pass(){ // Q
  if (!$round.classList.contains("active")) return;
  if (!running) return;
  if (actionLock) return;

  actionLock = true;

  // czerwona ramka + poka≈º odpowied≈∫ na CA≈ÅE 3 sekundy
  showWrong();
  showAnswerForCurrentImage();

  await wait(WRONG_HOLD_MS);

  hideAnswer();
  nextImageFor(active);     // ten sam gracz dostaje nowe zdjƒôcie
  renderTimers();

  clearPhotoFeedback();
  actionLock = false;
}

  function resetRound(){
    running = false;
    stopTick();
    timeA = ROUND_SECONDS;
    timeB = ROUND_SECONDS;
    active = "A";
    renderTimers();
  }
    // ====== FULLSCREEN ======
  function isFullscreen(){
    return !!document.fullscreenElement;
  }
  async function toggleFullscreen(){
    try{
      if (!isFullscreen()) {
        await document.getElementById("viewport").requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    }catch(e){
      console.error(e);
    }
  }
  fsBtn.addEventListener("click", toggleFullscreen);

  // ====== ANSWER PARSING FROM FILENAME ======
  // Obs≈Çuguje np: assets/k1/01.Nazwa_odpowiedzi.jpg
  function getAnswerFromSrc(src){
    try{
      const clean = src.split("?")[0];
      const file = clean.split("/").pop();          // 01.Nazwa.jpg
      const base = file.replace(/\.[^.]+$/, "");    // 01.Nazwa
      const parts = base.split(".");
      if (parts.length < 2) return "";              // np. 01 -> brak odpowiedzi
      const raw = parts.slice(1).join(".");         // Nazwa_odpowiedzi
      return decodeURIComponent(raw).replace(/_/g, " ").trim();
    }catch(e){
      return "";
    }
  }

function showAnswerForCurrentImage(){
  const txt = (currentAnswer || "").trim() || getAnswerFromSrc(photo.src);
  if (!txt) return false;
  answerEl.textContent = txt;
  answerEl.classList.add("show");
  return true;
}

  function hideAnswer(){
    answerEl.classList.remove("show");
    answerEl.textContent = "";
  }

  function clearPhotoFeedback(){
  if (!photoWrap) return;
  photoWrap.classList.remove("correct", "wrong");
}

function showCorrect(){
  if (!photoWrap) return;
  clearPhotoFeedback();
  photoWrap.classList.add("correct");
}

function showWrong(){
  if (!photoWrap) return;
  clearPhotoFeedback();
  photoWrap.classList.add("wrong");
}
  
  async function revealAnswerThen(doAfter){
    if (actionLock) return;
    actionLock = true;

    // poka≈º odpowied≈∫ dla AKTUALNIE wy≈õwietlanego zdjƒôcia (zanim je zmienimy)
    const shown = showAnswerForCurrentImage();

    // nawet je≈õli brak tekstu, robimy kr√≥tkƒÖ przerwƒô, ≈ºeby flow by≈Ço sta≈Çe
    await wait(ANSWER_MS);

    hideAnswer();
    doAfter();

    actionLock = false;
  }

  // ====== NAMES ======
  function getNameA(){ return (nameAInput.value || "").trim() || "Player A"; }
  function getNameB(){ return (nameBInput.value || "").trim() || "Player B"; }
  function loadNames(){
    nameAInput.value = localStorage.getItem(LS_A) || "";
    nameBInput.value = localStorage.getItem(LS_B) || "";
  }
  function saveNames(){
    localStorage.setItem(LS_A, (nameAInput.value || "").trim());
    localStorage.setItem(LS_B, (nameBInput.value || "").trim());
  }
  nameAInput.addEventListener("input", saveNames);
  nameBInput.addEventListener("input", saveNames);

  // ====== CATEGORY LABELS (editable display only) ======
  function loadCatLabels(){
    try{
      const raw = localStorage.getItem(LS_CAT);
      const arr = raw ? JSON.parse(raw) : null;
      if (Array.isArray(arr) && arr.length === 9) return arr;
    }catch(e){}
    // default: u≈ºyj kluczy (Kategoria1..)
    return categoryKeys.map((k, i) => `Kategoria ${i+1}`);
  }

  function saveCatLabels(){
    localStorage.setItem(LS_CAT, JSON.stringify(catLabels));
  }

  function renderMenu(){
    // Je≈õli operator wczyta≈Ç folder ‚Äî kafelki oparte o localCats
if (localMode) {
  // ograniczamy do 9 kategorii na ekranie
  // (kolejne mo≈ºesz dodaƒá potem jako przewijanie, ale to nastƒôpny krok)
}
    grid.innerHTML = "";
    for (let i = 0; i < 9; i++){
      const tile = document.createElement("div");
      tile.className = "tile";
      tile.onclick = () => selectCategory(i);

      const inp = document.createElement("input");
      inp.value = catLabels[i] || "";
      inp.placeholder = `Kategoria ${i+1}`;
      inp.addEventListener("click", (e) => e.stopPropagation());
      inp.addEventListener("keydown", (e) => e.stopPropagation());
      inp.addEventListener("input", () => {
        catLabels[i] = inp.value;
        saveCatLabels();
      });

      tile.appendChild(inp);
      grid.appendChild(tile);
    }
  }

  async function buildDecksForIndex(i){
    const key = categoryKeys[i];
    const cat = categories[key];

    const urls = [];
    for (let n = 1; n <= cat.count; n++){
      const nn = String(n).padStart(2, "0");
      urls.push(`${cat.dir}/${nn}.${cat.ext}`);
    }

    await Promise.all(urls.map(url => new Promise(resolve => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = url;
    })));

    deckA = shuffle([...urls]);
    deckB = shuffle([...urls]);
    idxA = 0; idxB = 0;
  }

  async function selectCategory(i){
    // ===== local mode =====
if (localMode) {
  saveNames();
  currentCatIndex = i;

  const cat = localCats[i];
  if (!cat) return;

  // Decki z obiekt√≥w {url, answer}
  const list = cat.images.slice();
  deckA = shuffle(list.slice());
  deckB = shuffle(list.slice());
  idxA = 0; idxB = 0;

  resetRound();
  startArmed = true;

  readyTitle.textContent = (catLabels[i] || cat.label || "").trim() || `Kategoria ${i+1}`;
  show($ready);
  return;
}

    saveNames();
    currentCatIndex = i;
    await buildDecksForIndex(i);

    resetRound();
    startArmed = true;

    readyTitle.textContent = (catLabels[i] || "").trim() || `Kategoria ${i+1}`;
    show($ready);
  }

  function wait(ms){ return new Promise(res => setTimeout(res, ms)); }

  async function startSequence(){
    if (!startArmed) return;
    startArmed = false;

    show($countdown);
    const steps = ["3","2","1","START"];
    for (const s of steps){
      countNum.textContent = s;
            // d≈∫wiƒôk odliczania: pik...pik...pik...piiiiiik
      if (s === "START") beep(1500, 1500);
      else beep(1000, 500);
      
      countNum.classList.add("go");
      await wait(110);
      countNum.classList.remove("go");
      await wait(STEP_MS - 110);
    }

    active = "A";
    nextImageFor("A");
    show($round);

    running = true;
    startTick();
    renderTimers();
  }

  // ====== KEYBOARD ======
  window.addEventListener("keydown", (e) => {
    const k = (e.key || "").toLowerCase();
      if (k === "f") { toggleFullscreen(); return; }

    // MENU: 1..9 wyb√≥r
    if ($menu.classList.contains("active")) {
      if (k >= "1" && k <= "9") { selectCategory(parseInt(k,10) - 1); return; }
    }

    // READY: Enter start
    if ($ready.classList.contains("active")) {
      if (k === "enter") { e.preventDefault(); startSequence(); return; }
    }

    // ROUND: Enter/Space ignoruj (brak pauzy)
    if ($round.classList.contains("active")) {
      if (k === "enter" || k === " ") { e.preventDefault(); return; }
      if (k === "p") { correct(); return; }
      if (k === "q") { pass(); return; }
    }

    // WINNER: M do menu, R restart tej samej kategorii
    if ($winner.classList.contains("active")) {
      if (k === "m") { show($menu); return; }
      if (k === "r") {
        if (currentCatIndex !== null) {
          resetRound();
          active = "A";
          nextImageFor("A");
          show($round);
          running = true;
          startTick();
          renderTimers();
        } else {
          show($menu);
        }
        return;
      }
    }
  }, {passive:false});

  // ====== INIT ======
  async function init(){
    loadNames();

    const res = await fetch("data/categories.json");
    categories = await res.json();
    categoryKeys = Object.keys(categories).slice(0, 9);

    catLabels = loadCatLabels();
    renderMenu();

    show($menu);
    renderTimers();
  }

  init().catch(err => console.error(err));
</script>

    </body>
  </div>

</html>
